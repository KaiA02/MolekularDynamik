// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "simulation.hxx"

// simulation
// 

const simulation::input_type& simulation::
input () const
{
  return this->input_.get ();
}

simulation::input_type& simulation::
input ()
{
  return this->input_.get ();
}

void simulation::
input (const input_type& x)
{
  this->input_.set (x);
}

void simulation::
input (::std::unique_ptr< input_type > x)
{
  this->input_.set (std::move (x));
}

const simulation::output_type& simulation::
output () const
{
  return this->output_.get ();
}

simulation::output_type& simulation::
output ()
{
  return this->output_.get ();
}

void simulation::
output (const output_type& x)
{
  this->output_.set (x);
}

void simulation::
output (::std::unique_ptr< output_type > x)
{
  this->output_.set (std::move (x));
}

const simulation::config_type& simulation::
config () const
{
  return this->config_.get ();
}

simulation::config_type& simulation::
config ()
{
  return this->config_.get ();
}

void simulation::
config (const config_type& x)
{
  this->config_.set (x);
}

void simulation::
config (::std::unique_ptr< config_type > x)
{
  this->config_.set (std::move (x));
}


// input
// 

const input::tStart_type& input::
tStart () const
{
  return this->tStart_.get ();
}

input::tStart_type& input::
tStart ()
{
  return this->tStart_.get ();
}

void input::
tStart (const tStart_type& x)
{
  this->tStart_.set (x);
}

const input::tEnd_type& input::
tEnd () const
{
  return this->tEnd_.get ();
}

input::tEnd_type& input::
tEnd ()
{
  return this->tEnd_.get ();
}

void input::
tEnd (const tEnd_type& x)
{
  this->tEnd_.set (x);
}

const input::deltaT_type& input::
deltaT () const
{
  return this->deltaT_.get ();
}

input::deltaT_type& input::
deltaT ()
{
  return this->deltaT_.get ();
}

void input::
deltaT (const deltaT_type& x)
{
  this->deltaT_.set (x);
}

const input::inputType_type& input::
inputType () const
{
  return this->inputType_.get ();
}

input::inputType_type& input::
inputType ()
{
  return this->inputType_.get ();
}

void input::
inputType (const inputType_type& x)
{
  this->inputType_.set (x);
}

void input::
inputType (::std::unique_ptr< inputType_type > x)
{
  this->inputType_.set (std::move (x));
}

const input::particleContainerType_type& input::
particleContainerType () const
{
  return this->particleContainerType_.get ();
}

input::particleContainerType_type& input::
particleContainerType ()
{
  return this->particleContainerType_.get ();
}

void input::
particleContainerType (const particleContainerType_type& x)
{
  this->particleContainerType_.set (x);
}

void input::
particleContainerType (::std::unique_ptr< particleContainerType_type > x)
{
  this->particleContainerType_.set (std::move (x));
}

const input::particles_sequence& input::
particles () const
{
  return this->particles_;
}

input::particles_sequence& input::
particles ()
{
  return this->particles_;
}

void input::
particles (const particles_sequence& s)
{
  this->particles_ = s;
}

const input::cuboids_sequence& input::
cuboids () const
{
  return this->cuboids_;
}

input::cuboids_sequence& input::
cuboids ()
{
  return this->cuboids_;
}

void input::
cuboids (const cuboids_sequence& s)
{
  this->cuboids_ = s;
}

const input::disk_sequence& input::
disk () const
{
  return this->disk_;
}

input::disk_sequence& input::
disk ()
{
  return this->disk_;
}

void input::
disk (const disk_sequence& s)
{
  this->disk_ = s;
}


// output
// 

const output::baseName_type& output::
baseName () const
{
  return this->baseName_.get ();
}

output::baseName_type& output::
baseName ()
{
  return this->baseName_.get ();
}

void output::
baseName (const baseName_type& x)
{
  this->baseName_.set (x);
}

void output::
baseName (::std::unique_ptr< baseName_type > x)
{
  this->baseName_.set (std::move (x));
}

const output::writeFrequency_type& output::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

output::writeFrequency_type& output::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void output::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}

const output::outputType_type& output::
outputType () const
{
  return this->outputType_.get ();
}

output::outputType_type& output::
outputType ()
{
  return this->outputType_.get ();
}

void output::
outputType (const outputType_type& x)
{
  this->outputType_.set (x);
}

void output::
outputType (::std::unique_ptr< outputType_type > x)
{
  this->outputType_.set (std::move (x));
}


// config
// 

const config::performanceMeasurement_optional& config::
performanceMeasurement () const
{
  return this->performanceMeasurement_;
}

config::performanceMeasurement_optional& config::
performanceMeasurement ()
{
  return this->performanceMeasurement_;
}

void config::
performanceMeasurement (const performanceMeasurement_type& x)
{
  this->performanceMeasurement_.set (x);
}

void config::
performanceMeasurement (const performanceMeasurement_optional& x)
{
  this->performanceMeasurement_ = x;
}

const config::logLevel_optional& config::
logLevel () const
{
  return this->logLevel_;
}

config::logLevel_optional& config::
logLevel ()
{
  return this->logLevel_;
}

void config::
logLevel (const logLevel_type& x)
{
  this->logLevel_.set (x);
}

void config::
logLevel (const logLevel_optional& x)
{
  this->logLevel_ = x;
}

void config::
logLevel (::std::unique_ptr< logLevel_type > x)
{
  this->logLevel_.set (std::move (x));
}


// particles
// 

const particles::x_type& particles::
x () const
{
  return this->x_.get ();
}

particles::x_type& particles::
x ()
{
  return this->x_.get ();
}

void particles::
x (const x_type& x)
{
  this->x_.set (x);
}

const particles::y_type& particles::
y () const
{
  return this->y_.get ();
}

particles::y_type& particles::
y ()
{
  return this->y_.get ();
}

void particles::
y (const y_type& x)
{
  this->y_.set (x);
}

const particles::z_type& particles::
z () const
{
  return this->z_.get ();
}

particles::z_type& particles::
z ()
{
  return this->z_.get ();
}

void particles::
z (const z_type& x)
{
  this->z_.set (x);
}

const particles::velocityX_type& particles::
velocityX () const
{
  return this->velocityX_.get ();
}

particles::velocityX_type& particles::
velocityX ()
{
  return this->velocityX_.get ();
}

void particles::
velocityX (const velocityX_type& x)
{
  this->velocityX_.set (x);
}

const particles::velocityY_type& particles::
velocityY () const
{
  return this->velocityY_.get ();
}

particles::velocityY_type& particles::
velocityY ()
{
  return this->velocityY_.get ();
}

void particles::
velocityY (const velocityY_type& x)
{
  this->velocityY_.set (x);
}

const particles::velocityZ_type& particles::
velocityZ () const
{
  return this->velocityZ_.get ();
}

particles::velocityZ_type& particles::
velocityZ ()
{
  return this->velocityZ_.get ();
}

void particles::
velocityZ (const velocityZ_type& x)
{
  this->velocityZ_.set (x);
}

const particles::mass_type& particles::
mass () const
{
  return this->mass_.get ();
}

particles::mass_type& particles::
mass ()
{
  return this->mass_.get ();
}

void particles::
mass (const mass_type& x)
{
  this->mass_.set (x);
}


// cuboids
// 

const cuboids::n1_type& cuboids::
n1 () const
{
  return this->n1_.get ();
}

cuboids::n1_type& cuboids::
n1 ()
{
  return this->n1_.get ();
}

void cuboids::
n1 (const n1_type& x)
{
  this->n1_.set (x);
}

const cuboids::n2_type& cuboids::
n2 () const
{
  return this->n2_.get ();
}

cuboids::n2_type& cuboids::
n2 ()
{
  return this->n2_.get ();
}

void cuboids::
n2 (const n2_type& x)
{
  this->n2_.set (x);
}

const cuboids::n3_type& cuboids::
n3 () const
{
  return this->n3_.get ();
}

cuboids::n3_type& cuboids::
n3 ()
{
  return this->n3_.get ();
}

void cuboids::
n3 (const n3_type& x)
{
  this->n3_.set (x);
}

const cuboids::distance_type& cuboids::
distance () const
{
  return this->distance_.get ();
}

cuboids::distance_type& cuboids::
distance ()
{
  return this->distance_.get ();
}

void cuboids::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

const cuboids::meanVelocity_type& cuboids::
meanVelocity () const
{
  return this->meanVelocity_.get ();
}

cuboids::meanVelocity_type& cuboids::
meanVelocity ()
{
  return this->meanVelocity_.get ();
}

void cuboids::
meanVelocity (const meanVelocity_type& x)
{
  this->meanVelocity_.set (x);
}

const cuboids::dimension_type& cuboids::
dimension () const
{
  return this->dimension_.get ();
}

cuboids::dimension_type& cuboids::
dimension ()
{
  return this->dimension_.get ();
}

void cuboids::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}


// disk
// 

const disk::radius_type& disk::
radius () const
{
  return this->radius_.get ();
}

disk::radius_type& disk::
radius ()
{
  return this->radius_.get ();
}

void disk::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const disk::distance_type& disk::
distance () const
{
  return this->distance_.get ();
}

disk::distance_type& disk::
distance ()
{
  return this->distance_.get ();
}

void disk::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

const disk::dimension_type& disk::
dimension () const
{
  return this->dimension_.get ();
}

disk::dimension_type& disk::
dimension ()
{
  return this->dimension_.get ();
}

void disk::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// simulation
//

simulation::
simulation (const input_type& input,
            const output_type& output,
            const config_type& config)
: ::xml_schema::type (),
  input_ (input, this),
  output_ (output, this),
  config_ (config, this)
{
}

simulation::
simulation (::std::unique_ptr< input_type > input,
            ::std::unique_ptr< output_type > output,
            ::std::unique_ptr< config_type > config)
: ::xml_schema::type (),
  input_ (std::move (input), this),
  output_ (std::move (output), this),
  config_ (std::move (config), this)
{
}

simulation::
simulation (const simulation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  input_ (x.input_, f, this),
  output_ (x.output_, f, this),
  config_ (x.config_, f, this)
{
}

simulation::
simulation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  input_ (this),
  output_ (this),
  config_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // input
    //
    if (n.name () == "input" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< input_type > r (
        input_traits::create (i, f, this));

      if (!input_.present ())
      {
        this->input_.set (::std::move (r));
        continue;
      }
    }

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!output_.present ())
      {
        this->output_.set (::std::move (r));
        continue;
      }
    }

    // config
    //
    if (n.name () == "config" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< config_type > r (
        config_traits::create (i, f, this));

      if (!config_.present ())
      {
        this->config_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!input_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "input",
      "");
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output",
      "");
  }

  if (!config_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "config",
      "");
  }
}

simulation* simulation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation (*this, f, c);
}

simulation& simulation::
operator= (const simulation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->input_ = x.input_;
    this->output_ = x.output_;
    this->config_ = x.config_;
  }

  return *this;
}

simulation::
~simulation ()
{
}

// input
//

input::
input (const tStart_type& tStart,
       const tEnd_type& tEnd,
       const deltaT_type& deltaT,
       const inputType_type& inputType,
       const particleContainerType_type& particleContainerType)
: ::xml_schema::type (),
  tStart_ (tStart, this),
  tEnd_ (tEnd, this),
  deltaT_ (deltaT, this),
  inputType_ (inputType, this),
  particleContainerType_ (particleContainerType, this),
  particles_ (this),
  cuboids_ (this),
  disk_ (this)
{
}

input::
input (const input& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  tStart_ (x.tStart_, f, this),
  tEnd_ (x.tEnd_, f, this),
  deltaT_ (x.deltaT_, f, this),
  inputType_ (x.inputType_, f, this),
  particleContainerType_ (x.particleContainerType_, f, this),
  particles_ (x.particles_, f, this),
  cuboids_ (x.cuboids_, f, this),
  disk_ (x.disk_, f, this)
{
}

input::
input (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  tStart_ (this),
  tEnd_ (this),
  deltaT_ (this),
  inputType_ (this),
  particleContainerType_ (this),
  particles_ (this),
  cuboids_ (this),
  disk_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void input::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // tStart
    //
    if (n.name () == "tStart" && n.namespace_ ().empty ())
    {
      if (!tStart_.present ())
      {
        this->tStart_.set (tStart_traits::create (i, f, this));
        continue;
      }
    }

    // tEnd
    //
    if (n.name () == "tEnd" && n.namespace_ ().empty ())
    {
      if (!tEnd_.present ())
      {
        this->tEnd_.set (tEnd_traits::create (i, f, this));
        continue;
      }
    }

    // deltaT
    //
    if (n.name () == "deltaT" && n.namespace_ ().empty ())
    {
      if (!deltaT_.present ())
      {
        this->deltaT_.set (deltaT_traits::create (i, f, this));
        continue;
      }
    }

    // inputType
    //
    if (n.name () == "inputType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< inputType_type > r (
        inputType_traits::create (i, f, this));

      if (!inputType_.present ())
      {
        this->inputType_.set (::std::move (r));
        continue;
      }
    }

    // particleContainerType
    //
    if (n.name () == "particleContainerType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particleContainerType_type > r (
        particleContainerType_traits::create (i, f, this));

      if (!particleContainerType_.present ())
      {
        this->particleContainerType_.set (::std::move (r));
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      this->particles_.push_back (::std::move (r));
      continue;
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      this->cuboids_.push_back (::std::move (r));
      continue;
    }

    // disk
    //
    if (n.name () == "disk" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< disk_type > r (
        disk_traits::create (i, f, this));

      this->disk_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!tStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tStart",
      "");
  }

  if (!tEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tEnd",
      "");
  }

  if (!deltaT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "deltaT",
      "");
  }

  if (!inputType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inputType",
      "");
  }

  if (!particleContainerType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particleContainerType",
      "");
  }
}

input* input::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class input (*this, f, c);
}

input& input::
operator= (const input& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->tStart_ = x.tStart_;
    this->tEnd_ = x.tEnd_;
    this->deltaT_ = x.deltaT_;
    this->inputType_ = x.inputType_;
    this->particleContainerType_ = x.particleContainerType_;
    this->particles_ = x.particles_;
    this->cuboids_ = x.cuboids_;
    this->disk_ = x.disk_;
  }

  return *this;
}

input::
~input ()
{
}

// output
//

output::
output (const baseName_type& baseName,
        const writeFrequency_type& writeFrequency,
        const outputType_type& outputType)
: ::xml_schema::type (),
  baseName_ (baseName, this),
  writeFrequency_ (writeFrequency, this),
  outputType_ (outputType, this)
{
}

output::
output (const output& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  baseName_ (x.baseName_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this),
  outputType_ (x.outputType_, f, this)
{
}

output::
output (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  baseName_ (this),
  writeFrequency_ (this),
  outputType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void output::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // baseName
    //
    if (n.name () == "baseName" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< baseName_type > r (
        baseName_traits::create (i, f, this));

      if (!baseName_.present ())
      {
        this->baseName_.set (::std::move (r));
        continue;
      }
    }

    // writeFrequency
    //
    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      if (!writeFrequency_.present ())
      {
        this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // outputType
    //
    if (n.name () == "outputType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< outputType_type > r (
        outputType_traits::create (i, f, this));

      if (!outputType_.present ())
      {
        this->outputType_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!baseName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseName",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "writeFrequency",
      "");
  }

  if (!outputType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputType",
      "");
  }
}

output* output::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class output (*this, f, c);
}

output& output::
operator= (const output& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->baseName_ = x.baseName_;
    this->writeFrequency_ = x.writeFrequency_;
    this->outputType_ = x.outputType_;
  }

  return *this;
}

output::
~output ()
{
}

// config
//

config::
config ()
: ::xml_schema::type (),
  performanceMeasurement_ (this),
  logLevel_ (this)
{
}

config::
config (const config& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  performanceMeasurement_ (x.performanceMeasurement_, f, this),
  logLevel_ (x.logLevel_, f, this)
{
}

config::
config (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  performanceMeasurement_ (this),
  logLevel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void config::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // performanceMeasurement
    //
    if (n.name () == "performanceMeasurement" && n.namespace_ ().empty ())
    {
      if (!this->performanceMeasurement_)
      {
        this->performanceMeasurement_.set (performanceMeasurement_traits::create (i, f, this));
        continue;
      }
    }

    // logLevel
    //
    if (n.name () == "logLevel" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< logLevel_type > r (
        logLevel_traits::create (i, f, this));

      if (!this->logLevel_)
      {
        this->logLevel_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

config* config::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class config (*this, f, c);
}

config& config::
operator= (const config& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->performanceMeasurement_ = x.performanceMeasurement_;
    this->logLevel_ = x.logLevel_;
  }

  return *this;
}

config::
~config ()
{
}

// particles
//

particles::
particles (const x_type& x,
           const y_type& y,
           const z_type& z,
           const velocityX_type& velocityX,
           const velocityY_type& velocityY,
           const velocityZ_type& velocityZ,
           const mass_type& mass)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  velocityX_ (velocityX, this),
  velocityY_ (velocityY, this),
  velocityZ_ (velocityZ, this),
  mass_ (mass, this)
{
}

particles::
particles (const particles& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  velocityX_ (x.velocityX_, f, this),
  velocityY_ (x.velocityY_, f, this),
  velocityZ_ (x.velocityZ_, f, this),
  mass_ (x.mass_, f, this)
{
}

particles::
particles (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this),
  velocityX_ (this),
  velocityY_ (this),
  velocityZ_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    // velocityX
    //
    if (n.name () == "velocityX" && n.namespace_ ().empty ())
    {
      if (!velocityX_.present ())
      {
        this->velocityX_.set (velocityX_traits::create (i, f, this));
        continue;
      }
    }

    // velocityY
    //
    if (n.name () == "velocityY" && n.namespace_ ().empty ())
    {
      if (!velocityY_.present ())
      {
        this->velocityY_.set (velocityY_traits::create (i, f, this));
        continue;
      }
    }

    // velocityZ
    //
    if (n.name () == "velocityZ" && n.namespace_ ().empty ())
    {
      if (!velocityZ_.present ())
      {
        this->velocityZ_.set (velocityZ_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }

  if (!velocityX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocityX",
      "");
  }

  if (!velocityY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocityY",
      "");
  }

  if (!velocityZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocityZ",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

particles* particles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particles (*this, f, c);
}

particles& particles::
operator= (const particles& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->velocityX_ = x.velocityX_;
    this->velocityY_ = x.velocityY_;
    this->velocityZ_ = x.velocityZ_;
    this->mass_ = x.mass_;
  }

  return *this;
}

particles::
~particles ()
{
}

// cuboids
//

cuboids::
cuboids (const n1_type& n1,
         const n2_type& n2,
         const n3_type& n3,
         const distance_type& distance,
         const meanVelocity_type& meanVelocity,
         const dimension_type& dimension)
: ::xml_schema::type (),
  n1_ (n1, this),
  n2_ (n2, this),
  n3_ (n3, this),
  distance_ (distance, this),
  meanVelocity_ (meanVelocity, this),
  dimension_ (dimension, this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  n1_ (x.n1_, f, this),
  n2_ (x.n2_, f, this),
  n3_ (x.n3_, f, this),
  distance_ (x.distance_, f, this),
  meanVelocity_ (x.meanVelocity_, f, this),
  dimension_ (x.dimension_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  n1_ (this),
  n2_ (this),
  n3_ (this),
  distance_ (this),
  meanVelocity_ (this),
  dimension_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // n1
    //
    if (n.name () == "n1" && n.namespace_ ().empty ())
    {
      if (!n1_.present ())
      {
        this->n1_.set (n1_traits::create (i, f, this));
        continue;
      }
    }

    // n2
    //
    if (n.name () == "n2" && n.namespace_ ().empty ())
    {
      if (!n2_.present ())
      {
        this->n2_.set (n2_traits::create (i, f, this));
        continue;
      }
    }

    // n3
    //
    if (n.name () == "n3" && n.namespace_ ().empty ())
    {
      if (!n3_.present ())
      {
        this->n3_.set (n3_traits::create (i, f, this));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      if (!distance_.present ())
      {
        this->distance_.set (distance_traits::create (i, f, this));
        continue;
      }
    }

    // meanVelocity
    //
    if (n.name () == "meanVelocity" && n.namespace_ ().empty ())
    {
      if (!meanVelocity_.present ())
      {
        this->meanVelocity_.set (meanVelocity_traits::create (i, f, this));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      if (!dimension_.present ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!n1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n1",
      "");
  }

  if (!n2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n2",
      "");
  }

  if (!n3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n3",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }

  if (!meanVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meanVelocity",
      "");
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->n1_ = x.n1_;
    this->n2_ = x.n2_;
    this->n3_ = x.n3_;
    this->distance_ = x.distance_;
    this->meanVelocity_ = x.meanVelocity_;
    this->dimension_ = x.dimension_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// disk
//

disk::
disk (const radius_type& radius,
      const distance_type& distance,
      const dimension_type& dimension)
: ::xml_schema::type (),
  radius_ (radius, this),
  distance_ (distance, this),
  dimension_ (dimension, this)
{
}

disk::
disk (const disk& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  radius_ (x.radius_, f, this),
  distance_ (x.distance_, f, this),
  dimension_ (x.dimension_, f, this)
{
}

disk::
disk (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  radius_ (this),
  distance_ (this),
  dimension_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void disk::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      if (!distance_.present ())
      {
        this->distance_.set (distance_traits::create (i, f, this));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      if (!dimension_.present ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }
}

disk* disk::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class disk (*this, f, c);
}

disk& disk::
operator= (const disk& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->radius_ = x.radius_;
    this->distance_ = x.distance_;
    this->dimension_ = x.dimension_;
  }

  return *this;
}

disk::
~disk ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::simulation > (
      ::simulation_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

::std::unique_ptr< ::simulation >
simulation_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

