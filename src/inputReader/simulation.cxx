// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "simulation.hxx"

// simulation
// 

const simulation::input_type& simulation::
input () const
{
  return this->input_.get ();
}

simulation::input_type& simulation::
input ()
{
  return this->input_.get ();
}

void simulation::
input (const input_type& x)
{
  this->input_.set (x);
}

void simulation::
input (::std::unique_ptr< input_type > x)
{
  this->input_.set (std::move (x));
}

const simulation::output_type& simulation::
output () const
{
  return this->output_.get ();
}

simulation::output_type& simulation::
output ()
{
  return this->output_.get ();
}

void simulation::
output (const output_type& x)
{
  this->output_.set (x);
}

void simulation::
output (::std::unique_ptr< output_type > x)
{
  this->output_.set (std::move (x));
}

const simulation::config_type& simulation::
config () const
{
  return this->config_.get ();
}

simulation::config_type& simulation::
config ()
{
  return this->config_.get ();
}

void simulation::
config (const config_type& x)
{
  this->config_.set (x);
}

void simulation::
config (::std::unique_ptr< config_type > x)
{
  this->config_.set (std::move (x));
}


// input
// 

const input::tStart_type& input::
tStart () const
{
  return this->tStart_.get ();
}

input::tStart_type& input::
tStart ()
{
  return this->tStart_.get ();
}

void input::
tStart (const tStart_type& x)
{
  this->tStart_.set (x);
}

const input::tEnd_type& input::
tEnd () const
{
  return this->tEnd_.get ();
}

input::tEnd_type& input::
tEnd ()
{
  return this->tEnd_.get ();
}

void input::
tEnd (const tEnd_type& x)
{
  this->tEnd_.set (x);
}

const input::deltaT_type& input::
deltaT () const
{
  return this->deltaT_.get ();
}

input::deltaT_type& input::
deltaT ()
{
  return this->deltaT_.get ();
}

void input::
deltaT (const deltaT_type& x)
{
  this->deltaT_.set (x);
}

const input::smoothLJ_type& input::
smoothLJ () const
{
  return this->smoothLJ_.get ();
}

input::smoothLJ_type& input::
smoothLJ ()
{
  return this->smoothLJ_.get ();
}

void input::
smoothLJ (const smoothLJ_type& x)
{
  this->smoothLJ_.set (x);
}

const input::particleContainerType_type& input::
particleContainerType () const
{
  return this->particleContainerType_.get ();
}

input::particleContainerType_type& input::
particleContainerType ()
{
  return this->particleContainerType_.get ();
}

void input::
particleContainerType (const particleContainerType_type& x)
{
  this->particleContainerType_.set (x);
}

void input::
particleContainerType (::std::unique_ptr< particleContainerType_type > x)
{
  this->particleContainerType_.set (std::move (x));
}

const input::r_cutoff_type& input::
r_cutoff () const
{
  return this->r_cutoff_.get ();
}

input::r_cutoff_type& input::
r_cutoff ()
{
  return this->r_cutoff_.get ();
}

void input::
r_cutoff (const r_cutoff_type& x)
{
  this->r_cutoff_.set (x);
}

const input::r_l_type& input::
r_l () const
{
  return this->r_l_.get ();
}

input::r_l_type& input::
r_l ()
{
  return this->r_l_.get ();
}

void input::
r_l (const r_l_type& x)
{
  this->r_l_.set (x);
}

const input::domainSizeX_type& input::
domainSizeX () const
{
  return this->domainSizeX_.get ();
}

input::domainSizeX_type& input::
domainSizeX ()
{
  return this->domainSizeX_.get ();
}

void input::
domainSizeX (const domainSizeX_type& x)
{
  this->domainSizeX_.set (x);
}

const input::domainSizeY_type& input::
domainSizeY () const
{
  return this->domainSizeY_.get ();
}

input::domainSizeY_type& input::
domainSizeY ()
{
  return this->domainSizeY_.get ();
}

void input::
domainSizeY (const domainSizeY_type& x)
{
  this->domainSizeY_.set (x);
}

const input::domainSizeZ_type& input::
domainSizeZ () const
{
  return this->domainSizeZ_.get ();
}

input::domainSizeZ_type& input::
domainSizeZ ()
{
  return this->domainSizeZ_.get ();
}

void input::
domainSizeZ (const domainSizeZ_type& x)
{
  this->domainSizeZ_.set (x);
}

const input::boundary1Type_type& input::
boundary1Type () const
{
  return this->boundary1Type_.get ();
}

input::boundary1Type_type& input::
boundary1Type ()
{
  return this->boundary1Type_.get ();
}

void input::
boundary1Type (const boundary1Type_type& x)
{
  this->boundary1Type_.set (x);
}

const input::boundary2Type_type& input::
boundary2Type () const
{
  return this->boundary2Type_.get ();
}

input::boundary2Type_type& input::
boundary2Type ()
{
  return this->boundary2Type_.get ();
}

void input::
boundary2Type (const boundary2Type_type& x)
{
  this->boundary2Type_.set (x);
}

const input::boundary3Type_type& input::
boundary3Type () const
{
  return this->boundary3Type_.get ();
}

input::boundary3Type_type& input::
boundary3Type ()
{
  return this->boundary3Type_.get ();
}

void input::
boundary3Type (const boundary3Type_type& x)
{
  this->boundary3Type_.set (x);
}

const input::boundary4Type_type& input::
boundary4Type () const
{
  return this->boundary4Type_.get ();
}

input::boundary4Type_type& input::
boundary4Type ()
{
  return this->boundary4Type_.get ();
}

void input::
boundary4Type (const boundary4Type_type& x)
{
  this->boundary4Type_.set (x);
}

const input::boundary5Type_type& input::
boundary5Type () const
{
  return this->boundary5Type_.get ();
}

input::boundary5Type_type& input::
boundary5Type ()
{
  return this->boundary5Type_.get ();
}

void input::
boundary5Type (const boundary5Type_type& x)
{
  this->boundary5Type_.set (x);
}

const input::boundary6Type_type& input::
boundary6Type () const
{
  return this->boundary6Type_.get ();
}

input::boundary6Type_type& input::
boundary6Type ()
{
  return this->boundary6Type_.get ();
}

void input::
boundary6Type (const boundary6Type_type& x)
{
  this->boundary6Type_.set (x);
}

const input::thermostatON_type& input::
thermostatON () const
{
  return this->thermostatON_.get ();
}

input::thermostatON_type& input::
thermostatON ()
{
  return this->thermostatON_.get ();
}

void input::
thermostatON (const thermostatON_type& x)
{
  this->thermostatON_.set (x);
}

void input::
thermostatON (::std::unique_ptr< thermostatON_type > x)
{
  this->thermostatON_.set (std::move (x));
}

const input::temp_init_type& input::
temp_init () const
{
  return this->temp_init_.get ();
}

input::temp_init_type& input::
temp_init ()
{
  return this->temp_init_.get ();
}

void input::
temp_init (const temp_init_type& x)
{
  this->temp_init_.set (x);
}

const input::n_thermostat_type& input::
n_thermostat () const
{
  return this->n_thermostat_.get ();
}

input::n_thermostat_type& input::
n_thermostat ()
{
  return this->n_thermostat_.get ();
}

void input::
n_thermostat (const n_thermostat_type& x)
{
  this->n_thermostat_.set (x);
}

const input::temp_target_type& input::
temp_target () const
{
  return this->temp_target_.get ();
}

input::temp_target_type& input::
temp_target ()
{
  return this->temp_target_.get ();
}

void input::
temp_target (const temp_target_type& x)
{
  this->temp_target_.set (x);
}

const input::delta_temp_type& input::
delta_temp () const
{
  return this->delta_temp_.get ();
}

input::delta_temp_type& input::
delta_temp ()
{
  return this->delta_temp_.get ();
}

void input::
delta_temp (const delta_temp_type& x)
{
  this->delta_temp_.set (x);
}

const input::g_grav_type& input::
g_grav () const
{
  return this->g_grav_.get ();
}

input::g_grav_type& input::
g_grav ()
{
  return this->g_grav_.get ();
}

void input::
g_grav (const g_grav_type& x)
{
  this->g_grav_.set (x);
}

const input::particles_sequence& input::
particles () const
{
  return this->particles_;
}

input::particles_sequence& input::
particles ()
{
  return this->particles_;
}

void input::
particles (const particles_sequence& s)
{
  this->particles_ = s;
}

const input::cuboids_sequence& input::
cuboids () const
{
  return this->cuboids_;
}

input::cuboids_sequence& input::
cuboids ()
{
  return this->cuboids_;
}

void input::
cuboids (const cuboids_sequence& s)
{
  this->cuboids_ = s;
}

const input::disk_sequence& input::
disk () const
{
  return this->disk_;
}

input::disk_sequence& input::
disk ()
{
  return this->disk_;
}

void input::
disk (const disk_sequence& s)
{
  this->disk_ = s;
}

const input::membrane_sequence& input::
membrane () const
{
  return this->membrane_;
}

input::membrane_sequence& input::
membrane ()
{
  return this->membrane_;
}

void input::
membrane (const membrane_sequence& s)
{
  this->membrane_ = s;
}


// output
// 

const output::baseName_type& output::
baseName () const
{
  return this->baseName_.get ();
}

output::baseName_type& output::
baseName ()
{
  return this->baseName_.get ();
}

void output::
baseName (const baseName_type& x)
{
  this->baseName_.set (x);
}

void output::
baseName (::std::unique_ptr< baseName_type > x)
{
  this->baseName_.set (std::move (x));
}

const output::writeFrequency_type& output::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

output::writeFrequency_type& output::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void output::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}

const output::outputType_type& output::
outputType () const
{
  return this->outputType_.get ();
}

output::outputType_type& output::
outputType ()
{
  return this->outputType_.get ();
}

void output::
outputType (const outputType_type& x)
{
  this->outputType_.set (x);
}

void output::
outputType (::std::unique_ptr< outputType_type > x)
{
  this->outputType_.set (std::move (x));
}


// config
// 

const config::performanceMeasurement_optional& config::
performanceMeasurement () const
{
  return this->performanceMeasurement_;
}

config::performanceMeasurement_optional& config::
performanceMeasurement ()
{
  return this->performanceMeasurement_;
}

void config::
performanceMeasurement (const performanceMeasurement_type& x)
{
  this->performanceMeasurement_.set (x);
}

void config::
performanceMeasurement (const performanceMeasurement_optional& x)
{
  this->performanceMeasurement_ = x;
}

const config::logLevel_optional& config::
logLevel () const
{
  return this->logLevel_;
}

config::logLevel_optional& config::
logLevel ()
{
  return this->logLevel_;
}

void config::
logLevel (const logLevel_type& x)
{
  this->logLevel_.set (x);
}

void config::
logLevel (const logLevel_optional& x)
{
  this->logLevel_ = x;
}

void config::
logLevel (::std::unique_ptr< logLevel_type > x)
{
  this->logLevel_.set (std::move (x));
}


// particles
// 

const particles::x_type& particles::
x () const
{
  return this->x_.get ();
}

particles::x_type& particles::
x ()
{
  return this->x_.get ();
}

void particles::
x (const x_type& x)
{
  this->x_.set (x);
}

const particles::y_type& particles::
y () const
{
  return this->y_.get ();
}

particles::y_type& particles::
y ()
{
  return this->y_.get ();
}

void particles::
y (const y_type& x)
{
  this->y_.set (x);
}

const particles::z_type& particles::
z () const
{
  return this->z_.get ();
}

particles::z_type& particles::
z ()
{
  return this->z_.get ();
}

void particles::
z (const z_type& x)
{
  this->z_.set (x);
}

const particles::velocityX_type& particles::
velocityX () const
{
  return this->velocityX_.get ();
}

particles::velocityX_type& particles::
velocityX ()
{
  return this->velocityX_.get ();
}

void particles::
velocityX (const velocityX_type& x)
{
  this->velocityX_.set (x);
}

const particles::velocityY_type& particles::
velocityY () const
{
  return this->velocityY_.get ();
}

particles::velocityY_type& particles::
velocityY ()
{
  return this->velocityY_.get ();
}

void particles::
velocityY (const velocityY_type& x)
{
  this->velocityY_.set (x);
}

const particles::velocityZ_type& particles::
velocityZ () const
{
  return this->velocityZ_.get ();
}

particles::velocityZ_type& particles::
velocityZ ()
{
  return this->velocityZ_.get ();
}

void particles::
velocityZ (const velocityZ_type& x)
{
  this->velocityZ_.set (x);
}

const particles::mass_type& particles::
mass () const
{
  return this->mass_.get ();
}

particles::mass_type& particles::
mass ()
{
  return this->mass_.get ();
}

void particles::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const particles::epsilon_type& particles::
epsilon () const
{
  return this->epsilon_.get ();
}

particles::epsilon_type& particles::
epsilon ()
{
  return this->epsilon_.get ();
}

void particles::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const particles::sigma_type& particles::
sigma () const
{
  return this->sigma_.get ();
}

particles::sigma_type& particles::
sigma ()
{
  return this->sigma_.get ();
}

void particles::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}


// cuboids
// 

const cuboids::n1_type& cuboids::
n1 () const
{
  return this->n1_.get ();
}

cuboids::n1_type& cuboids::
n1 ()
{
  return this->n1_.get ();
}

void cuboids::
n1 (const n1_type& x)
{
  this->n1_.set (x);
}

const cuboids::n2_type& cuboids::
n2 () const
{
  return this->n2_.get ();
}

cuboids::n2_type& cuboids::
n2 ()
{
  return this->n2_.get ();
}

void cuboids::
n2 (const n2_type& x)
{
  this->n2_.set (x);
}

const cuboids::n3_type& cuboids::
n3 () const
{
  return this->n3_.get ();
}

cuboids::n3_type& cuboids::
n3 ()
{
  return this->n3_.get ();
}

void cuboids::
n3 (const n3_type& x)
{
  this->n3_.set (x);
}

const cuboids::distance_type& cuboids::
distance () const
{
  return this->distance_.get ();
}

cuboids::distance_type& cuboids::
distance ()
{
  return this->distance_.get ();
}

void cuboids::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

const cuboids::meanVelocity_type& cuboids::
meanVelocity () const
{
  return this->meanVelocity_.get ();
}

cuboids::meanVelocity_type& cuboids::
meanVelocity ()
{
  return this->meanVelocity_.get ();
}

void cuboids::
meanVelocity (const meanVelocity_type& x)
{
  this->meanVelocity_.set (x);
}

const cuboids::dimension_type& cuboids::
dimension () const
{
  return this->dimension_.get ();
}

cuboids::dimension_type& cuboids::
dimension ()
{
  return this->dimension_.get ();
}

void cuboids::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}


// disk
// 

const disk::radius_type& disk::
radius () const
{
  return this->radius_.get ();
}

disk::radius_type& disk::
radius ()
{
  return this->radius_.get ();
}

void disk::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const disk::distance_type& disk::
distance () const
{
  return this->distance_.get ();
}

disk::distance_type& disk::
distance ()
{
  return this->distance_.get ();
}

void disk::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

const disk::meanVelocity_type& disk::
meanVelocity () const
{
  return this->meanVelocity_.get ();
}

disk::meanVelocity_type& disk::
meanVelocity ()
{
  return this->meanVelocity_.get ();
}

void disk::
meanVelocity (const meanVelocity_type& x)
{
  this->meanVelocity_.set (x);
}

const disk::dimension_type& disk::
dimension () const
{
  return this->dimension_.get ();
}

disk::dimension_type& disk::
dimension ()
{
  return this->dimension_.get ();
}

void disk::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}


// membrane
// 

const membrane::n1_type& membrane::
n1 () const
{
  return this->n1_.get ();
}

membrane::n1_type& membrane::
n1 ()
{
  return this->n1_.get ();
}

void membrane::
n1 (const n1_type& x)
{
  this->n1_.set (x);
}

const membrane::n2_type& membrane::
n2 () const
{
  return this->n2_.get ();
}

membrane::n2_type& membrane::
n2 ()
{
  return this->n2_.get ();
}

void membrane::
n2 (const n2_type& x)
{
  this->n2_.set (x);
}

const membrane::n3_type& membrane::
n3 () const
{
  return this->n3_.get ();
}

membrane::n3_type& membrane::
n3 ()
{
  return this->n3_.get ();
}

void membrane::
n3 (const n3_type& x)
{
  this->n3_.set (x);
}

const membrane::distance_type& membrane::
distance () const
{
  return this->distance_.get ();
}

membrane::distance_type& membrane::
distance ()
{
  return this->distance_.get ();
}

void membrane::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

const membrane::meanVelocity_type& membrane::
meanVelocity () const
{
  return this->meanVelocity_.get ();
}

membrane::meanVelocity_type& membrane::
meanVelocity ()
{
  return this->meanVelocity_.get ();
}

void membrane::
meanVelocity (const meanVelocity_type& x)
{
  this->meanVelocity_.set (x);
}

const membrane::forceUpwards_type& membrane::
forceUpwards () const
{
  return this->forceUpwards_.get ();
}

membrane::forceUpwards_type& membrane::
forceUpwards ()
{
  return this->forceUpwards_.get ();
}

void membrane::
forceUpwards (const forceUpwards_type& x)
{
  this->forceUpwards_.set (x);
}

const membrane::id1a_type& membrane::
id1a () const
{
  return this->id1a_.get ();
}

membrane::id1a_type& membrane::
id1a ()
{
  return this->id1a_.get ();
}

void membrane::
id1a (const id1a_type& x)
{
  this->id1a_.set (x);
}

const membrane::id1b_type& membrane::
id1b () const
{
  return this->id1b_.get ();
}

membrane::id1b_type& membrane::
id1b ()
{
  return this->id1b_.get ();
}

void membrane::
id1b (const id1b_type& x)
{
  this->id1b_.set (x);
}

const membrane::id2a_type& membrane::
id2a () const
{
  return this->id2a_.get ();
}

membrane::id2a_type& membrane::
id2a ()
{
  return this->id2a_.get ();
}

void membrane::
id2a (const id2a_type& x)
{
  this->id2a_.set (x);
}

const membrane::id2b_type& membrane::
id2b () const
{
  return this->id2b_.get ();
}

membrane::id2b_type& membrane::
id2b ()
{
  return this->id2b_.get ();
}

void membrane::
id2b (const id2b_type& x)
{
  this->id2b_.set (x);
}

const membrane::id3a_type& membrane::
id3a () const
{
  return this->id3a_.get ();
}

membrane::id3a_type& membrane::
id3a ()
{
  return this->id3a_.get ();
}

void membrane::
id3a (const id3a_type& x)
{
  this->id3a_.set (x);
}

const membrane::id3b_type& membrane::
id3b () const
{
  return this->id3b_.get ();
}

membrane::id3b_type& membrane::
id3b ()
{
  return this->id3b_.get ();
}

void membrane::
id3b (const id3b_type& x)
{
  this->id3b_.set (x);
}

const membrane::id4a_type& membrane::
id4a () const
{
  return this->id4a_.get ();
}

membrane::id4a_type& membrane::
id4a ()
{
  return this->id4a_.get ();
}

void membrane::
id4a (const id4a_type& x)
{
  this->id4a_.set (x);
}

const membrane::id4b_type& membrane::
id4b () const
{
  return this->id4b_.get ();
}

membrane::id4b_type& membrane::
id4b ()
{
  return this->id4b_.get ();
}

void membrane::
id4b (const id4b_type& x)
{
  this->id4b_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// simulation
//

simulation::
simulation (const input_type& input,
            const output_type& output,
            const config_type& config)
: ::xml_schema::type (),
  input_ (input, this),
  output_ (output, this),
  config_ (config, this)
{
}

simulation::
simulation (::std::unique_ptr< input_type > input,
            ::std::unique_ptr< output_type > output,
            ::std::unique_ptr< config_type > config)
: ::xml_schema::type (),
  input_ (std::move (input), this),
  output_ (std::move (output), this),
  config_ (std::move (config), this)
{
}

simulation::
simulation (const simulation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  input_ (x.input_, f, this),
  output_ (x.output_, f, this),
  config_ (x.config_, f, this)
{
}

simulation::
simulation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  input_ (this),
  output_ (this),
  config_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // input
    //
    if (n.name () == "input" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< input_type > r (
        input_traits::create (i, f, this));

      if (!input_.present ())
      {
        this->input_.set (::std::move (r));
        continue;
      }
    }

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!output_.present ())
      {
        this->output_.set (::std::move (r));
        continue;
      }
    }

    // config
    //
    if (n.name () == "config" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< config_type > r (
        config_traits::create (i, f, this));

      if (!config_.present ())
      {
        this->config_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!input_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "input",
      "");
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output",
      "");
  }

  if (!config_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "config",
      "");
  }
}

simulation* simulation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation (*this, f, c);
}

simulation& simulation::
operator= (const simulation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->input_ = x.input_;
    this->output_ = x.output_;
    this->config_ = x.config_;
  }

  return *this;
}

simulation::
~simulation ()
{
}

// input
//

input::
input (const tStart_type& tStart,
       const tEnd_type& tEnd,
       const deltaT_type& deltaT,
       const smoothLJ_type& smoothLJ,
       const particleContainerType_type& particleContainerType,
       const r_cutoff_type& r_cutoff,
       const r_l_type& r_l,
       const domainSizeX_type& domainSizeX,
       const domainSizeY_type& domainSizeY,
       const domainSizeZ_type& domainSizeZ,
       const boundary1Type_type& boundary1Type,
       const boundary2Type_type& boundary2Type,
       const boundary3Type_type& boundary3Type,
       const boundary4Type_type& boundary4Type,
       const boundary5Type_type& boundary5Type,
       const boundary6Type_type& boundary6Type,
       const thermostatON_type& thermostatON,
       const temp_init_type& temp_init,
       const n_thermostat_type& n_thermostat,
       const temp_target_type& temp_target,
       const delta_temp_type& delta_temp,
       const g_grav_type& g_grav)
: ::xml_schema::type (),
  tStart_ (tStart, this),
  tEnd_ (tEnd, this),
  deltaT_ (deltaT, this),
  smoothLJ_ (smoothLJ, this),
  particleContainerType_ (particleContainerType, this),
  r_cutoff_ (r_cutoff, this),
  r_l_ (r_l, this),
  domainSizeX_ (domainSizeX, this),
  domainSizeY_ (domainSizeY, this),
  domainSizeZ_ (domainSizeZ, this),
  boundary1Type_ (boundary1Type, this),
  boundary2Type_ (boundary2Type, this),
  boundary3Type_ (boundary3Type, this),
  boundary4Type_ (boundary4Type, this),
  boundary5Type_ (boundary5Type, this),
  boundary6Type_ (boundary6Type, this),
  thermostatON_ (thermostatON, this),
  temp_init_ (temp_init, this),
  n_thermostat_ (n_thermostat, this),
  temp_target_ (temp_target, this),
  delta_temp_ (delta_temp, this),
  g_grav_ (g_grav, this),
  particles_ (this),
  cuboids_ (this),
  disk_ (this),
  membrane_ (this)
{
}

input::
input (const input& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  tStart_ (x.tStart_, f, this),
  tEnd_ (x.tEnd_, f, this),
  deltaT_ (x.deltaT_, f, this),
  smoothLJ_ (x.smoothLJ_, f, this),
  particleContainerType_ (x.particleContainerType_, f, this),
  r_cutoff_ (x.r_cutoff_, f, this),
  r_l_ (x.r_l_, f, this),
  domainSizeX_ (x.domainSizeX_, f, this),
  domainSizeY_ (x.domainSizeY_, f, this),
  domainSizeZ_ (x.domainSizeZ_, f, this),
  boundary1Type_ (x.boundary1Type_, f, this),
  boundary2Type_ (x.boundary2Type_, f, this),
  boundary3Type_ (x.boundary3Type_, f, this),
  boundary4Type_ (x.boundary4Type_, f, this),
  boundary5Type_ (x.boundary5Type_, f, this),
  boundary6Type_ (x.boundary6Type_, f, this),
  thermostatON_ (x.thermostatON_, f, this),
  temp_init_ (x.temp_init_, f, this),
  n_thermostat_ (x.n_thermostat_, f, this),
  temp_target_ (x.temp_target_, f, this),
  delta_temp_ (x.delta_temp_, f, this),
  g_grav_ (x.g_grav_, f, this),
  particles_ (x.particles_, f, this),
  cuboids_ (x.cuboids_, f, this),
  disk_ (x.disk_, f, this),
  membrane_ (x.membrane_, f, this)
{
}

input::
input (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  tStart_ (this),
  tEnd_ (this),
  deltaT_ (this),
  smoothLJ_ (this),
  particleContainerType_ (this),
  r_cutoff_ (this),
  r_l_ (this),
  domainSizeX_ (this),
  domainSizeY_ (this),
  domainSizeZ_ (this),
  boundary1Type_ (this),
  boundary2Type_ (this),
  boundary3Type_ (this),
  boundary4Type_ (this),
  boundary5Type_ (this),
  boundary6Type_ (this),
  thermostatON_ (this),
  temp_init_ (this),
  n_thermostat_ (this),
  temp_target_ (this),
  delta_temp_ (this),
  g_grav_ (this),
  particles_ (this),
  cuboids_ (this),
  disk_ (this),
  membrane_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void input::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // tStart
    //
    if (n.name () == "tStart" && n.namespace_ ().empty ())
    {
      if (!tStart_.present ())
      {
        this->tStart_.set (tStart_traits::create (i, f, this));
        continue;
      }
    }

    // tEnd
    //
    if (n.name () == "tEnd" && n.namespace_ ().empty ())
    {
      if (!tEnd_.present ())
      {
        this->tEnd_.set (tEnd_traits::create (i, f, this));
        continue;
      }
    }

    // deltaT
    //
    if (n.name () == "deltaT" && n.namespace_ ().empty ())
    {
      if (!deltaT_.present ())
      {
        this->deltaT_.set (deltaT_traits::create (i, f, this));
        continue;
      }
    }

    // smoothLJ
    //
    if (n.name () == "smoothLJ" && n.namespace_ ().empty ())
    {
      if (!smoothLJ_.present ())
      {
        this->smoothLJ_.set (smoothLJ_traits::create (i, f, this));
        continue;
      }
    }

    // particleContainerType
    //
    if (n.name () == "particleContainerType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particleContainerType_type > r (
        particleContainerType_traits::create (i, f, this));

      if (!particleContainerType_.present ())
      {
        this->particleContainerType_.set (::std::move (r));
        continue;
      }
    }

    // r_cutoff
    //
    if (n.name () == "r_cutoff" && n.namespace_ ().empty ())
    {
      if (!r_cutoff_.present ())
      {
        this->r_cutoff_.set (r_cutoff_traits::create (i, f, this));
        continue;
      }
    }

    // r_l
    //
    if (n.name () == "r_l" && n.namespace_ ().empty ())
    {
      if (!r_l_.present ())
      {
        this->r_l_.set (r_l_traits::create (i, f, this));
        continue;
      }
    }

    // domainSizeX
    //
    if (n.name () == "domainSizeX" && n.namespace_ ().empty ())
    {
      if (!domainSizeX_.present ())
      {
        this->domainSizeX_.set (domainSizeX_traits::create (i, f, this));
        continue;
      }
    }

    // domainSizeY
    //
    if (n.name () == "domainSizeY" && n.namespace_ ().empty ())
    {
      if (!domainSizeY_.present ())
      {
        this->domainSizeY_.set (domainSizeY_traits::create (i, f, this));
        continue;
      }
    }

    // domainSizeZ
    //
    if (n.name () == "domainSizeZ" && n.namespace_ ().empty ())
    {
      if (!domainSizeZ_.present ())
      {
        this->domainSizeZ_.set (domainSizeZ_traits::create (i, f, this));
        continue;
      }
    }

    // boundary1Type
    //
    if (n.name () == "boundary1Type" && n.namespace_ ().empty ())
    {
      if (!boundary1Type_.present ())
      {
        this->boundary1Type_.set (boundary1Type_traits::create (i, f, this));
        continue;
      }
    }

    // boundary2Type
    //
    if (n.name () == "boundary2Type" && n.namespace_ ().empty ())
    {
      if (!boundary2Type_.present ())
      {
        this->boundary2Type_.set (boundary2Type_traits::create (i, f, this));
        continue;
      }
    }

    // boundary3Type
    //
    if (n.name () == "boundary3Type" && n.namespace_ ().empty ())
    {
      if (!boundary3Type_.present ())
      {
        this->boundary3Type_.set (boundary3Type_traits::create (i, f, this));
        continue;
      }
    }

    // boundary4Type
    //
    if (n.name () == "boundary4Type" && n.namespace_ ().empty ())
    {
      if (!boundary4Type_.present ())
      {
        this->boundary4Type_.set (boundary4Type_traits::create (i, f, this));
        continue;
      }
    }

    // boundary5Type
    //
    if (n.name () == "boundary5Type" && n.namespace_ ().empty ())
    {
      if (!boundary5Type_.present ())
      {
        this->boundary5Type_.set (boundary5Type_traits::create (i, f, this));
        continue;
      }
    }

    // boundary6Type
    //
    if (n.name () == "boundary6Type" && n.namespace_ ().empty ())
    {
      if (!boundary6Type_.present ())
      {
        this->boundary6Type_.set (boundary6Type_traits::create (i, f, this));
        continue;
      }
    }

    // thermostatON
    //
    if (n.name () == "thermostatON" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< thermostatON_type > r (
        thermostatON_traits::create (i, f, this));

      if (!thermostatON_.present ())
      {
        this->thermostatON_.set (::std::move (r));
        continue;
      }
    }

    // temp_init
    //
    if (n.name () == "temp_init" && n.namespace_ ().empty ())
    {
      if (!temp_init_.present ())
      {
        this->temp_init_.set (temp_init_traits::create (i, f, this));
        continue;
      }
    }

    // n_thermostat
    //
    if (n.name () == "n_thermostat" && n.namespace_ ().empty ())
    {
      if (!n_thermostat_.present ())
      {
        this->n_thermostat_.set (n_thermostat_traits::create (i, f, this));
        continue;
      }
    }

    // temp_target
    //
    if (n.name () == "temp_target" && n.namespace_ ().empty ())
    {
      if (!temp_target_.present ())
      {
        this->temp_target_.set (temp_target_traits::create (i, f, this));
        continue;
      }
    }

    // delta_temp
    //
    if (n.name () == "delta_temp" && n.namespace_ ().empty ())
    {
      if (!delta_temp_.present ())
      {
        this->delta_temp_.set (delta_temp_traits::create (i, f, this));
        continue;
      }
    }

    // g_grav
    //
    if (n.name () == "g_grav" && n.namespace_ ().empty ())
    {
      if (!g_grav_.present ())
      {
        this->g_grav_.set (g_grav_traits::create (i, f, this));
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      this->particles_.push_back (::std::move (r));
      continue;
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      this->cuboids_.push_back (::std::move (r));
      continue;
    }

    // disk
    //
    if (n.name () == "disk" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< disk_type > r (
        disk_traits::create (i, f, this));

      this->disk_.push_back (::std::move (r));
      continue;
    }

    // membrane
    //
    if (n.name () == "membrane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< membrane_type > r (
        membrane_traits::create (i, f, this));

      this->membrane_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!tStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tStart",
      "");
  }

  if (!tEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tEnd",
      "");
  }

  if (!deltaT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "deltaT",
      "");
  }

  if (!smoothLJ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "smoothLJ",
      "");
  }

  if (!particleContainerType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particleContainerType",
      "");
  }

  if (!r_cutoff_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r_cutoff",
      "");
  }

  if (!r_l_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r_l",
      "");
  }

  if (!domainSizeX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainSizeX",
      "");
  }

  if (!domainSizeY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainSizeY",
      "");
  }

  if (!domainSizeZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainSizeZ",
      "");
  }

  if (!boundary1Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary1Type",
      "");
  }

  if (!boundary2Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary2Type",
      "");
  }

  if (!boundary3Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary3Type",
      "");
  }

  if (!boundary4Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary4Type",
      "");
  }

  if (!boundary5Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary5Type",
      "");
  }

  if (!boundary6Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary6Type",
      "");
  }

  if (!thermostatON_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "thermostatON",
      "");
  }

  if (!temp_init_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "temp_init",
      "");
  }

  if (!n_thermostat_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n_thermostat",
      "");
  }

  if (!temp_target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "temp_target",
      "");
  }

  if (!delta_temp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_temp",
      "");
  }

  if (!g_grav_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "g_grav",
      "");
  }
}

input* input::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class input (*this, f, c);
}

input& input::
operator= (const input& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->tStart_ = x.tStart_;
    this->tEnd_ = x.tEnd_;
    this->deltaT_ = x.deltaT_;
    this->smoothLJ_ = x.smoothLJ_;
    this->particleContainerType_ = x.particleContainerType_;
    this->r_cutoff_ = x.r_cutoff_;
    this->r_l_ = x.r_l_;
    this->domainSizeX_ = x.domainSizeX_;
    this->domainSizeY_ = x.domainSizeY_;
    this->domainSizeZ_ = x.domainSizeZ_;
    this->boundary1Type_ = x.boundary1Type_;
    this->boundary2Type_ = x.boundary2Type_;
    this->boundary3Type_ = x.boundary3Type_;
    this->boundary4Type_ = x.boundary4Type_;
    this->boundary5Type_ = x.boundary5Type_;
    this->boundary6Type_ = x.boundary6Type_;
    this->thermostatON_ = x.thermostatON_;
    this->temp_init_ = x.temp_init_;
    this->n_thermostat_ = x.n_thermostat_;
    this->temp_target_ = x.temp_target_;
    this->delta_temp_ = x.delta_temp_;
    this->g_grav_ = x.g_grav_;
    this->particles_ = x.particles_;
    this->cuboids_ = x.cuboids_;
    this->disk_ = x.disk_;
    this->membrane_ = x.membrane_;
  }

  return *this;
}

input::
~input ()
{
}

// output
//

output::
output (const baseName_type& baseName,
        const writeFrequency_type& writeFrequency,
        const outputType_type& outputType)
: ::xml_schema::type (),
  baseName_ (baseName, this),
  writeFrequency_ (writeFrequency, this),
  outputType_ (outputType, this)
{
}

output::
output (const output& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  baseName_ (x.baseName_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this),
  outputType_ (x.outputType_, f, this)
{
}

output::
output (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  baseName_ (this),
  writeFrequency_ (this),
  outputType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void output::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // baseName
    //
    if (n.name () == "baseName" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< baseName_type > r (
        baseName_traits::create (i, f, this));

      if (!baseName_.present ())
      {
        this->baseName_.set (::std::move (r));
        continue;
      }
    }

    // writeFrequency
    //
    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      if (!writeFrequency_.present ())
      {
        this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // outputType
    //
    if (n.name () == "outputType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< outputType_type > r (
        outputType_traits::create (i, f, this));

      if (!outputType_.present ())
      {
        this->outputType_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!baseName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseName",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "writeFrequency",
      "");
  }

  if (!outputType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputType",
      "");
  }
}

output* output::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class output (*this, f, c);
}

output& output::
operator= (const output& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->baseName_ = x.baseName_;
    this->writeFrequency_ = x.writeFrequency_;
    this->outputType_ = x.outputType_;
  }

  return *this;
}

output::
~output ()
{
}

// config
//

config::
config ()
: ::xml_schema::type (),
  performanceMeasurement_ (this),
  logLevel_ (this)
{
}

config::
config (const config& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  performanceMeasurement_ (x.performanceMeasurement_, f, this),
  logLevel_ (x.logLevel_, f, this)
{
}

config::
config (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  performanceMeasurement_ (this),
  logLevel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void config::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // performanceMeasurement
    //
    if (n.name () == "performanceMeasurement" && n.namespace_ ().empty ())
    {
      if (!this->performanceMeasurement_)
      {
        this->performanceMeasurement_.set (performanceMeasurement_traits::create (i, f, this));
        continue;
      }
    }

    // logLevel
    //
    if (n.name () == "logLevel" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< logLevel_type > r (
        logLevel_traits::create (i, f, this));

      if (!this->logLevel_)
      {
        this->logLevel_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

config* config::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class config (*this, f, c);
}

config& config::
operator= (const config& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->performanceMeasurement_ = x.performanceMeasurement_;
    this->logLevel_ = x.logLevel_;
  }

  return *this;
}

config::
~config ()
{
}

// particles
//

particles::
particles (const x_type& x,
           const y_type& y,
           const z_type& z,
           const velocityX_type& velocityX,
           const velocityY_type& velocityY,
           const velocityZ_type& velocityZ,
           const mass_type& mass,
           const epsilon_type& epsilon,
           const sigma_type& sigma)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  velocityX_ (velocityX, this),
  velocityY_ (velocityY, this),
  velocityZ_ (velocityZ, this),
  mass_ (mass, this),
  epsilon_ (epsilon, this),
  sigma_ (sigma, this)
{
}

particles::
particles (const particles& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  velocityX_ (x.velocityX_, f, this),
  velocityY_ (x.velocityY_, f, this),
  velocityZ_ (x.velocityZ_, f, this),
  mass_ (x.mass_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this)
{
}

particles::
particles (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this),
  velocityX_ (this),
  velocityY_ (this),
  velocityZ_ (this),
  mass_ (this),
  epsilon_ (this),
  sigma_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    // velocityX
    //
    if (n.name () == "velocityX" && n.namespace_ ().empty ())
    {
      if (!velocityX_.present ())
      {
        this->velocityX_.set (velocityX_traits::create (i, f, this));
        continue;
      }
    }

    // velocityY
    //
    if (n.name () == "velocityY" && n.namespace_ ().empty ())
    {
      if (!velocityY_.present ())
      {
        this->velocityY_.set (velocityY_traits::create (i, f, this));
        continue;
      }
    }

    // velocityZ
    //
    if (n.name () == "velocityZ" && n.namespace_ ().empty ())
    {
      if (!velocityZ_.present ())
      {
        this->velocityZ_.set (velocityZ_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }

  if (!velocityX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocityX",
      "");
  }

  if (!velocityY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocityY",
      "");
  }

  if (!velocityZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocityZ",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }
}

particles* particles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particles (*this, f, c);
}

particles& particles::
operator= (const particles& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->velocityX_ = x.velocityX_;
    this->velocityY_ = x.velocityY_;
    this->velocityZ_ = x.velocityZ_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
  }

  return *this;
}

particles::
~particles ()
{
}

// cuboids
//

cuboids::
cuboids (const n1_type& n1,
         const n2_type& n2,
         const n3_type& n3,
         const distance_type& distance,
         const meanVelocity_type& meanVelocity,
         const dimension_type& dimension)
: ::xml_schema::type (),
  n1_ (n1, this),
  n2_ (n2, this),
  n3_ (n3, this),
  distance_ (distance, this),
  meanVelocity_ (meanVelocity, this),
  dimension_ (dimension, this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  n1_ (x.n1_, f, this),
  n2_ (x.n2_, f, this),
  n3_ (x.n3_, f, this),
  distance_ (x.distance_, f, this),
  meanVelocity_ (x.meanVelocity_, f, this),
  dimension_ (x.dimension_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  n1_ (this),
  n2_ (this),
  n3_ (this),
  distance_ (this),
  meanVelocity_ (this),
  dimension_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // n1
    //
    if (n.name () == "n1" && n.namespace_ ().empty ())
    {
      if (!n1_.present ())
      {
        this->n1_.set (n1_traits::create (i, f, this));
        continue;
      }
    }

    // n2
    //
    if (n.name () == "n2" && n.namespace_ ().empty ())
    {
      if (!n2_.present ())
      {
        this->n2_.set (n2_traits::create (i, f, this));
        continue;
      }
    }

    // n3
    //
    if (n.name () == "n3" && n.namespace_ ().empty ())
    {
      if (!n3_.present ())
      {
        this->n3_.set (n3_traits::create (i, f, this));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      if (!distance_.present ())
      {
        this->distance_.set (distance_traits::create (i, f, this));
        continue;
      }
    }

    // meanVelocity
    //
    if (n.name () == "meanVelocity" && n.namespace_ ().empty ())
    {
      if (!meanVelocity_.present ())
      {
        this->meanVelocity_.set (meanVelocity_traits::create (i, f, this));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      if (!dimension_.present ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!n1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n1",
      "");
  }

  if (!n2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n2",
      "");
  }

  if (!n3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n3",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }

  if (!meanVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meanVelocity",
      "");
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->n1_ = x.n1_;
    this->n2_ = x.n2_;
    this->n3_ = x.n3_;
    this->distance_ = x.distance_;
    this->meanVelocity_ = x.meanVelocity_;
    this->dimension_ = x.dimension_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// disk
//

disk::
disk (const radius_type& radius,
      const distance_type& distance,
      const meanVelocity_type& meanVelocity,
      const dimension_type& dimension)
: ::xml_schema::type (),
  radius_ (radius, this),
  distance_ (distance, this),
  meanVelocity_ (meanVelocity, this),
  dimension_ (dimension, this)
{
}

disk::
disk (const disk& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  radius_ (x.radius_, f, this),
  distance_ (x.distance_, f, this),
  meanVelocity_ (x.meanVelocity_, f, this),
  dimension_ (x.dimension_, f, this)
{
}

disk::
disk (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  radius_ (this),
  distance_ (this),
  meanVelocity_ (this),
  dimension_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void disk::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      if (!distance_.present ())
      {
        this->distance_.set (distance_traits::create (i, f, this));
        continue;
      }
    }

    // meanVelocity
    //
    if (n.name () == "meanVelocity" && n.namespace_ ().empty ())
    {
      if (!meanVelocity_.present ())
      {
        this->meanVelocity_.set (meanVelocity_traits::create (i, f, this));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      if (!dimension_.present ())
      {
        this->dimension_.set (dimension_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }

  if (!meanVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meanVelocity",
      "");
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }
}

disk* disk::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class disk (*this, f, c);
}

disk& disk::
operator= (const disk& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->radius_ = x.radius_;
    this->distance_ = x.distance_;
    this->meanVelocity_ = x.meanVelocity_;
    this->dimension_ = x.dimension_;
  }

  return *this;
}

disk::
~disk ()
{
}

// membrane
//

membrane::
membrane (const n1_type& n1,
          const n2_type& n2,
          const n3_type& n3,
          const distance_type& distance,
          const meanVelocity_type& meanVelocity,
          const forceUpwards_type& forceUpwards,
          const id1a_type& id1a,
          const id1b_type& id1b,
          const id2a_type& id2a,
          const id2b_type& id2b,
          const id3a_type& id3a,
          const id3b_type& id3b,
          const id4a_type& id4a,
          const id4b_type& id4b)
: ::xml_schema::type (),
  n1_ (n1, this),
  n2_ (n2, this),
  n3_ (n3, this),
  distance_ (distance, this),
  meanVelocity_ (meanVelocity, this),
  forceUpwards_ (forceUpwards, this),
  id1a_ (id1a, this),
  id1b_ (id1b, this),
  id2a_ (id2a, this),
  id2b_ (id2b, this),
  id3a_ (id3a, this),
  id3b_ (id3b, this),
  id4a_ (id4a, this),
  id4b_ (id4b, this)
{
}

membrane::
membrane (const membrane& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  n1_ (x.n1_, f, this),
  n2_ (x.n2_, f, this),
  n3_ (x.n3_, f, this),
  distance_ (x.distance_, f, this),
  meanVelocity_ (x.meanVelocity_, f, this),
  forceUpwards_ (x.forceUpwards_, f, this),
  id1a_ (x.id1a_, f, this),
  id1b_ (x.id1b_, f, this),
  id2a_ (x.id2a_, f, this),
  id2b_ (x.id2b_, f, this),
  id3a_ (x.id3a_, f, this),
  id3b_ (x.id3b_, f, this),
  id4a_ (x.id4a_, f, this),
  id4b_ (x.id4b_, f, this)
{
}

membrane::
membrane (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  n1_ (this),
  n2_ (this),
  n3_ (this),
  distance_ (this),
  meanVelocity_ (this),
  forceUpwards_ (this),
  id1a_ (this),
  id1b_ (this),
  id2a_ (this),
  id2b_ (this),
  id3a_ (this),
  id3b_ (this),
  id4a_ (this),
  id4b_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void membrane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // n1
    //
    if (n.name () == "n1" && n.namespace_ ().empty ())
    {
      if (!n1_.present ())
      {
        this->n1_.set (n1_traits::create (i, f, this));
        continue;
      }
    }

    // n2
    //
    if (n.name () == "n2" && n.namespace_ ().empty ())
    {
      if (!n2_.present ())
      {
        this->n2_.set (n2_traits::create (i, f, this));
        continue;
      }
    }

    // n3
    //
    if (n.name () == "n3" && n.namespace_ ().empty ())
    {
      if (!n3_.present ())
      {
        this->n3_.set (n3_traits::create (i, f, this));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      if (!distance_.present ())
      {
        this->distance_.set (distance_traits::create (i, f, this));
        continue;
      }
    }

    // meanVelocity
    //
    if (n.name () == "meanVelocity" && n.namespace_ ().empty ())
    {
      if (!meanVelocity_.present ())
      {
        this->meanVelocity_.set (meanVelocity_traits::create (i, f, this));
        continue;
      }
    }

    // forceUpwards
    //
    if (n.name () == "forceUpwards" && n.namespace_ ().empty ())
    {
      if (!forceUpwards_.present ())
      {
        this->forceUpwards_.set (forceUpwards_traits::create (i, f, this));
        continue;
      }
    }

    // id1a
    //
    if (n.name () == "id1a" && n.namespace_ ().empty ())
    {
      if (!id1a_.present ())
      {
        this->id1a_.set (id1a_traits::create (i, f, this));
        continue;
      }
    }

    // id1b
    //
    if (n.name () == "id1b" && n.namespace_ ().empty ())
    {
      if (!id1b_.present ())
      {
        this->id1b_.set (id1b_traits::create (i, f, this));
        continue;
      }
    }

    // id2a
    //
    if (n.name () == "id2a" && n.namespace_ ().empty ())
    {
      if (!id2a_.present ())
      {
        this->id2a_.set (id2a_traits::create (i, f, this));
        continue;
      }
    }

    // id2b
    //
    if (n.name () == "id2b" && n.namespace_ ().empty ())
    {
      if (!id2b_.present ())
      {
        this->id2b_.set (id2b_traits::create (i, f, this));
        continue;
      }
    }

    // id3a
    //
    if (n.name () == "id3a" && n.namespace_ ().empty ())
    {
      if (!id3a_.present ())
      {
        this->id3a_.set (id3a_traits::create (i, f, this));
        continue;
      }
    }

    // id3b
    //
    if (n.name () == "id3b" && n.namespace_ ().empty ())
    {
      if (!id3b_.present ())
      {
        this->id3b_.set (id3b_traits::create (i, f, this));
        continue;
      }
    }

    // id4a
    //
    if (n.name () == "id4a" && n.namespace_ ().empty ())
    {
      if (!id4a_.present ())
      {
        this->id4a_.set (id4a_traits::create (i, f, this));
        continue;
      }
    }

    // id4b
    //
    if (n.name () == "id4b" && n.namespace_ ().empty ())
    {
      if (!id4b_.present ())
      {
        this->id4b_.set (id4b_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!n1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n1",
      "");
  }

  if (!n2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n2",
      "");
  }

  if (!n3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n3",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }

  if (!meanVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meanVelocity",
      "");
  }

  if (!forceUpwards_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "forceUpwards",
      "");
  }

  if (!id1a_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id1a",
      "");
  }

  if (!id1b_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id1b",
      "");
  }

  if (!id2a_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id2a",
      "");
  }

  if (!id2b_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id2b",
      "");
  }

  if (!id3a_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id3a",
      "");
  }

  if (!id3b_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id3b",
      "");
  }

  if (!id4a_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id4a",
      "");
  }

  if (!id4b_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id4b",
      "");
  }
}

membrane* membrane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class membrane (*this, f, c);
}

membrane& membrane::
operator= (const membrane& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->n1_ = x.n1_;
    this->n2_ = x.n2_;
    this->n3_ = x.n3_;
    this->distance_ = x.distance_;
    this->meanVelocity_ = x.meanVelocity_;
    this->forceUpwards_ = x.forceUpwards_;
    this->id1a_ = x.id1a_;
    this->id1b_ = x.id1b_;
    this->id2a_ = x.id2a_;
    this->id2b_ = x.id2b_;
    this->id3a_ = x.id3a_;
    this->id3b_ = x.id3b_;
    this->id4a_ = x.id4a_;
    this->id4b_ = x.id4b_;
  }

  return *this;
}

membrane::
~membrane ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation > (
    ::simulation_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::simulation > (
      ::simulation_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

::std::unique_ptr< ::simulation >
simulation_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

