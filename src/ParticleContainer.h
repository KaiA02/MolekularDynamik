#ifndef PARTICLECONTAINER_H
#define PARTICLECONTAINER_H

#include <optional>

#include "Particle.h"
#include <vector>
#include "LinkedCell/Cell.h"

/**
 * @brief The BaseParticleContainer class
 * This class is a base container for Particles. It contains a vector of Particles
 * and provides basic operations for managing Particles.
 */
class BaseParticleContainer {
public:
    virtual ~BaseParticleContainer() = default;
     /**
     * @brief add a Particle to the vector
     * @param particle Particle to add
     */
    virtual void addParticle(const Particle &particle) = 0;
    virtual std::vector<Cell> getCells() = 0;
    /**
     * @brief replaces a particle in the vector particles at index position
     * @param p new Particle
     * @param position index in particles
     */
    virtual void setParticle(Particle p, int position) = 0;

    /**
     * @brief resets all particles in the container
     */
    virtual void resetParticles() = 0;

    /**
     * @brief gets all particles in the container
     * @return reference to vector of particles
     */
    virtual std::vector<Particle>& getParticles() = 0;
    virtual const std::vector<Particle> &getParticles() const = 0;

    /**
     * @brief gets the number of particles in the container
     * @return number of particles
     */
    virtual int size() const = 0;

   virtual std::vector<Particle>::iterator begin() = 0;
   virtual std::vector<Particle>::iterator end() = 0;
   virtual std::vector<Particle>::const_iterator begin() const = 0;
   virtual std::vector<Particle>::const_iterator end() const = 0;
   virtual void handleLJFCalculation() = 0;

protected:
 std::vector<Particle> particles;
};

/**
 * @brief The ParticleContainer class
 * This class is a container for Particles. It contains a vector of Particles
 * and a 2D vector of pairings.
 */
class ParticleContainer : public BaseParticleContainer {
public:
  ParticleContainer();
 /**
  * @param particle: Particle that will be added to the vector
  */
  void addParticle(const Particle &particle) override;
  void setParticle(Particle p, int position) override;
  void resetParticles() override;
  std::vector<Particle> &getParticles() override;
  const std::vector<Particle> &getParticles() const override;
  std::vector<Cell> getCells();
  int size() const override;

  std::vector<Particle>::iterator begin() override;
  std::vector<Particle>::iterator end() override;
  std::vector<Particle>::const_iterator begin() const override;
  std::vector<Particle>::const_iterator end() const override;

  void handleLJFCalculation() override;

  /**
   * @brief adds a cuboid of particles to the vector particles
   * @param particleCube cuboid generated by the ParticleGenerator
   */
  void addMultipleParticles(std::vector<Particle> particleCube);

  /**
   * @brief adds a disk of particles to the vector particles
   * @param particleDisk disk generated by the ParticleGenerator
   */
  // void addDisk(std::vector<Particle> particleDisk);
};

/**
 * @brief The LCParticleContainer class
 * This class is a container for Particles using the linked cell algorithm.
 */
class LCParticleContainer : public ParticleContainer {
public:
 void setR_cutoff(double r_cutoff);
 /**
  *@brief realocates the particles to their new cells and also
  *implements the outflow boundary (managing the deltion of particles out of the domain)
 */
 void realocateParticles();

 /**
  *@brief adds the particles to the cells
 */
 void fillCellsWithParticles();

 /**
  *@brief returns all particles of neighbouring cells
  *@param id id from the celss
 */
 std::vector<Particle> getParticleInNeighbourhood(std::array<int, 3> id);

 Cell* getCellById(std::array<int, 3> id);
 /**
  *@brief generate all cells with according size
  *@param size_x size of x axis
  *@param size_y size of y axis
  *@param size_z size of z axis
  *@param r_cutoff  cutoff value for cells
 */
 void generateCells(int size_x, int size_y, int size_z, double r_cutoff);

 void setBoundarys(std::array<int, 6> in);
 /**
  *@brief calls realocateParticle() and calculates LJF for all cells
 */
 void handleLJFCalculation() override;
 /**
  *@brief adds the particle to all particles
  *and calls addParticleToCell(p)
 */
 void addParticle(Particle p);
 /**
 *@brief adds the particle to the according cell
 *returns true, if particle is correct added
*/
 bool addParticleToCell(Particle& p);
 std::vector<Particle>& getParticles();
 /**
 *@brief adds all new Particles to the existing particle list
 *@param newParticles vector of new Particles
*/
 void addMultipleParticles(std::vector<Particle>& newParticles);
 std::vector<Cell> getCells();
 /**
  *@brief checks if the cell exists
  *@param id from according cell
 */
 bool cellExists(std::array<int, 3> id);
 /**
  *@brief only for programmers to debug
 */
 void countParticlesInCells();


 std::vector<Particle*> getBoundaryParticles();
 void handleBoundaryAction();
 std::array<double, 6> getInfluencingBoundarysWithDistance(Particle*);
 std::array<int,3> findOponentCellID(std::array<int,3>id);
 std::array<double, 3> findOponentXYZ(std::array<double, 3> XYZ);
 void calcWithHalo(Particle* p, std::array<double, 3> x_arg, std::array<double, 3> v_arg);

private:
 std::vector<Cell> cells;
 std::array<double, 3> cell_size;
 std::array<int, 3> cell_count;
 std::array<int, 6> boundary_types;
 double r_cutoff;


};

#endif // PARTICLECONTAINER_H
